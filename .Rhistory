my_pois
colMeans(my_pois)
cm <- colMeans(my_pois)
hist(cm)
d1 <- Sys.Date
d1 <- Sys.Date()
class(d1)
unclass(d1)
d1
d2 <- as.Date("1969-01-01")
unclass(d2)
t1 <- Sys.time()
t1
class(t1)
unclass(t1)
t2 <- as.POSIXlt(Sys.time())
class(t2)
unclass(t2)
t2
unclass(t2)
str(unclass(t2))
t2$min
weekdays(d1)
months(t1)
quarters(t2)
t3 <- "October 17, 1986 08:24"
strptime(t2,%B %d, %Y %H:%M)
strptime(t3, "%B %d, %Y %H:%M")
t4 <- strptime(t3, "%B %d, %Y %H:%M")
t4
class(t4)
Sys.time() > t1
Sys.time()-t1
difftime(Sys.time(), t1, units='days')
RenuSum <- function(x,y) {
x+y
}
RenuSum(2,89)
dataset <=read.csv("C:\Data Science Toolbox\hw1_data.csv")
dataset <=read.csv("C:/Data Science Toolbox/hw1_data.csv")
dataset <=read.csv("C:/Data Science Toolbox/hw1_data.csv", header=TRUE)
dataset <- read.csv("C:/Data Science Toolbox/hw1_data.csv", header=TRUE)
dataset <- read.csv("C:/Data Science Toolbox/hw1_data.csv", header=TRUE)
head(dataset)
RenuMean <- function(x,n) {
y <- mean(x[ ,ncol(n)],na.rm=TRUE)
y
}
RenuMean(2)
RenuMean(dataset,2)
RenuMean <- function(x,n) {
mean(x[,n],na.rm=TRUE)
}
}
RenuMean <- function(x,n) {
y<- mean(x[,n],na.rm=TRUE)
}
RenuMean(dataset,2)
y
RenuMean <- function(x,n) {
y<- mean(x[,n],na.rm=TRUE)
y
}
RenuMean(dataset,2)
dataset <- read.csv("C:/Data Science Toolbox/Data/rprog_data_specdata/specdata/001.csv"
, header=TRUE)
# get the mean of a column
Mean <- function(x,name) {
y<- mean(x[,name],na.rm=TRUE)
y
}
# get the mean of a column
Mean <- function(x,name) {
y<- mean(x$name,na.rm=TRUE)
y
}
RenuMean(dataset,sulphate)
RenuMean(dataset,sulfate)
dataset <- read.csv("C:/Data Science Toolbox/Data/rprog_data_specdata/specdata/001.csv"
, header=TRUE)
# get the mean of a column
Mean <- function(x,name) {
y<- mean(x$name,na.rm=TRUE)
y
}
dataset <- read.csv("C:/Data Science Toolbox/Data/rprog_data_specdata/specdata/001.csv"
head(dataset)
dataset <- read.csv("C:/Data Science Toolbox/Data/rprog_data_specdata/specdata/001.csv",
header=TRUE)
dataset <- read.csv("C:/Data Science Toolbox/Data/rprog_data_specdata/specdata/001.csv",
header=TRUE)
head(dataset)
# get the mean of a column
RenuMean   <- function(x,name) {
y<- mean(x$name,na.rm=TRUE)
y
}
RenuMean(dataset,sulfate)
RenuMean   <- function(x,n) {
y<- mean(x[,n],na.rm=TRUE)
y
}
RenuMean(dataset,2)
RenuMean(dataset,3)
# read dataset with header
dataset <- read.csv("C:/Data Science Toolbox/Data/rprog_data_specdata/specdata/270.csv",
header=TRUE)
head(dataset)
# get the mean of a column
RenuMean   <- function(x,n) {
y<- mean(x[,n],na.rm=TRUE)
y
}
RenuMean(dataset,2)
RenuMean(dataset,3)
y <- mean(dataset$sulfate,na.rm=TRUE)
y
MeanByName   <- function(x,$n) {
y<- mean(x$n,na.rm=TRUE)
y
}
MeanByName(dataset,sulfate)
MeanByName   <- function(x,$n) {
y<- mean(x.$.n,na.rm=TRUE)
y
}
MeanByName(dataset,sulfate)
mean(paste("dataset","$","sulfate",sep="")
mean
mean(paste("dataset","$","sulfate",sep=""))
sum(paste("dataset","$","sulfate",sep=""))
MeanByName   <- function(x,n) {
y <- mean(X$n,na.rm=TRUE)
y
}
MeanByName(dataset,sulfate)
MeanByName   <- function(x,n) {
y <- mean(x$n,na.rm=TRUE)
y
}
MeanByName(dataset,sulfate)
MeanByName(dataset,nitrate)
for (n in 1:100)
{
plus2[n] = [n]+2
}
for (n in 1:100, by=1)
{
plus2 = n+2
plus2
for(i in 1:10) {
print(i)
}
for(i in 1:10) {
print(i)
i
}
x <- c("a", "b", "c", "d")
for(i in 1:4) {
print(x[i])
}
for(i in seq_along(x)) {
print(x[i])
}
x <- c("a", "b", "c", "d")
for(i in seq_along(x)) {
y<-x[i]
y
}
y
y
f1 <- function(x,y) {
x+y
}
f1(4,8)
fi
f1
f1
f1 <- function(x, y) {
x+y
}
f1( 3, 4)
f1(4,8)
f1 <- function(x, y) {
x+y
}
f1( 3, 4)
f1 <- function(x, y) {
x+y
}
f1( 3, 4)
f.bad <- function(x, y) {
z1 <- 2*x + y
z2 <- x + 2*y
z3 <- 2*x + 2*y
z4 <- x/y
}
f.bad(1, 2)
f.good <- function(x, y) {
z1 <- 2*x + y
z2 <- x + 2*y
z3 <- 2*x + 2*y
z4 <- x/y
return( z1, z2, z3, z4)
}
f.good(1, 2)
f.bad <- function(x, y) {
z1 <- 2*x + y
z2 <- x + 2*y
z3 <- 2*x + 2*y
z4 <- x/y
}
f.bad(1, 2)
sapply(paste("C:/Data Science Toolbox/Data/rprog_data_specdata/Test/Temp",
1:4, sep=".csv"),
read.csv)
sapply(paste("C:/Data Science Toolbox/Data/rprog_data_specdata/Test/Temp_",
1:2, sep=".csv"), read.csv)
sapply(paste("C:/Data Science Toolbox/Data/rprog_data_specdata/Test/Temp_",
1:2, ".csv", sep=""), read.csv)
sapply(paste("C:/Data Science Toolbox/Data/rprog_data_specdata/specdata/",
100:200, ".csv", sep=""), read.csv)
DataAll <- sapply(paste("C:/Data Science Toolbox/Data
/rprog_data_specdata/specdata/",
100:200, ".csv", sep=""), read.csv)
DataAll <- sapply(paste("C:/Data Science Toolbox/Data/rprog_data_specdata/specdata/",
100:102, ".csv", sep=""), read.csv)
head(DataAll)
head(DataAll)
x <- c("a", "b", "c", "d")
for(i in seq_along(x)) {
y<-x[i]
y
}
DataAll <- sapply(paste("C:/Data Science Toolbox/Data/rprog_data_specdata/specdata/",
100:102, ".csv", sep=""), read.csv, header=TRUE)
head(DataAll)
?list.files
fileList <- list.files(path="C:/Data Science Toolbox/Data/rprog_data_specdata/specdata/", pattern=".csv")
fileList
sapply(fileList, read.csv, header=TRUE)
fileList
fileList <- list.files(path="C:/Data Science Toolbox/Data/rprog_data_specdata/specdata/", pattern=".csv")
for(i in seq_along(fileList)) {
data=read.csv("fileList[i]",header=TRUE)
}
data_dir <- paste(getwd(),dir,sep = "/")
a=available.packages()
head(a,10)
install.packages("KernSmooth")
library(KernSmooth)
printmessage=function(x) {
if (x>0)
print ("x is greater than zero")
else
print("x is less than or equal to zero")
}
printmessage(10)
printmessage(-1)
printmessage=function(x) {
if (x>0)
print ("x is greater than zero")
else
print("x is less than or equal to zero")
invisible(x)
}
printmessage(-1)
# write three functions
?rep
x=c(2,3)
y=rep(x,4)
y2=solve(y)
# write three functions
x=c(2,3)
y=c(1,2)
y1=rowbind(x,y)
y2=solve(y1)
# write three functions
x=c(2,3)
y=c(1,2)
y1=rbind(x,y)
y2=solve(y1)
y1
y2
y1*y2
?solve
x=c(1,1)
y=c(1,2)
y1=rbind(x,y)
y2=solve(y1)
y1
y2
y1*y2
x=c(1,1)
y=c(1,2)
y1=rbind(x,y)
y2=solve(y1)
y1
y2
y1%*% y2
makeCacheMatrix <- function(x = matrix()) {
m<-NULL
set<-function(y){
x<<-y
m<<-NULL
}
get<-function() x
setmatrix<-function(solve) m<<- solve
getmatrix<-function() m
list(set=set, get=get,
setmatrix=setmatrix,
getmatrix=getmatrix)
}
cacheSolve <- function(x=matrix(), ...) {
m<-x$getmatrix()
if(!is.null(m)){
message("getting cached data")
return(m)
}
matrix<-x$get()
m<-solve(matrix, ...)
x$setmatrix(m)
m
}
x=c(1,1)
y=c(1,2)
Renumatrix=rbind(x,y)
cachesolve(Renumatrix)
cacheSolve(Renumatrix)
makeCacheMatrix <- function(x = matrix()) {
## @x: a square invertible matrix
## return: a list containing functions to
##              1. set the matrix
##              2. get the matrix
##              3. set the inverse
##              4. get the inverse
##         this list is used as the input to cacheSolve()
inv = NULL
set = function(y) {
# use `<<-` to assign a value to an object in an environment
# different from the current environment.
x <<- y
inv <<- NULL
}
get = function() x
setinv = function(inverse) inv <<- inverse
getinv = function() inv
list(set=set, get=get, setinv=setinv, getinv=getinv)
}
cacheSolve <- function(x, ...) {
## @x: output of makeCacheMatrix()
## return: inverse of the original matrix input to makeCacheMatrix()
inv = x$getinv()
# if the inverse has already been calculated
if (!is.null(inv)){
# get it from the cache and skips the computation.
message("getting cached data")
return(inv)
}
# otherwise, calculates the inverse
mat.data = x$get()
inv = solve(mat.data, ...)
# sets the value of the inverse in the cache via the setinv function.
x$setinv(inv)
return(inv)
}
test = function(mat){
## @mat: an invertible matrix
temp = makeCacheMatrix(mat)
start.time = Sys.time()
cacheSolve(temp)
dur = Sys.time() - start.time
print(dur)
start.time = Sys.time()
cacheSolve(temp)
dur = Sys.time() - start.time
print(dur)
}
set.seed(1110201)
r = rnorm(1000000)
mat1 = matrix(r, nrow=1000, ncol=1000)
test(mat1)
x=c(1,2)
y=c(3,4)
z=rbind(x,y)
z
zinverse=solve(z)
zinverse
set.seed(1110201)
r = rnorm(1000000)
mat1 = matrix(r, nrow=1000, ncol=1000)
test(mat1)
makeVector <- function(x = numeric()) {
m <- NULL
set <- function(y) {
x <<- y
m <<- NULL
}
get <- function() x
setmean <- function(mean) m <<- mean
getmean <- function() m
list(set = set, get = get,
setmean = setmean,
getmean = getmean)
}
cachemean <- function(x, ...) {
m <- x$getmean()
if(!is.null(m)) {
message("getting cached data")
return(m)
}
data <- x$get()
m <- mean(data, ...)
x$setmean(m)
m
}
set.seed(1110201)
r = rnorm(1000000)
temp = makeVector(r)
cachemean(temp)
cachemean(temp)
temp = makeVector(r)
start.time = Sys.time()
cachemean(temp)
dur = Sys.time() - start.time
print(dur)
start.time = Sys.time()
cachemean(temp)
dur = Sys.time() - start.time
print(dur)
set.seed(1110201)
r = rnorm(100000000)
temp = makeVector(r)
start.time = Sys.time()
cachemean(temp)
dur = Sys.time() - start.time
print(dur)
start.time = Sys.time()
cachemean(temp)
dur = Sys.time() - start.time
print(dur)
## Two functions first makeCacheMatrix and then cacheSolve
# Comments
# returns a list containing functions to get the matrix,
# set the matrix, get the inverse, set the inverse
# input to cacheSolve function
makeCacheMatrix <- function(x = matrix()) {
inv = NULL
set = function(y) {
# use `<<-` to assign a value to an object in an environment
# different from the current environment.
x <<- y
inv <<- NULL
}
get = function() x
setinv = function(inverse) inv <<- inverse
getinv = function() inv
list(set=set, get=get, setinv=setinv, getinv=getinv)
}
# return: inverse of the original matrix input to makeCacheMatrix()
cacheSolve <- function(x, ...) {
inv = x$getinv()
# if the inverse has already been calculated
if (!is.null(inv)){
# get it from the cache and skips the computation.
message("getting cached data")
return(inv)
}
# otherwise, calculates the inverse
mat.data = x$get()
inv = solve(mat.data, ...)
# sets the value of the inverse in the cache via the setinv function.
x$setinv(inv)
return(inv)
}
gettidy <- function(){
library(data.table)
# load test data
subject_test = read.table("UCI HAR Dataset/test/subject_test.txt")
data_test = read.table("UCI HAR Dataset/test/X_test.txt")
act_test = read.table("UCI HAR Dataset/test/Y_test.txt")
# load training data
subject_train = read.table("UCI HAR Dataset/train/subject_train.txt")
data_train = read.table("UCI HAR Dataset/train/X_train.txt")
act_train = read.table("UCI HAR Dataset/train/Y_train.txt")
# load lookup information
features <- read.table("UCI HAR Dataset/features.txt", col.names=c("featureId", "featureLabel"))
activities <- read.table("UCI HAR Dataset/activity_labels.txt", col.names=c("activityId", "activityLabel"))
activities$activityLabel <- gsub("_", "", as.character(activities$activityLabel))
includedFeatures <- grep("-mean\\(\\)|-std\\(\\)", features$featureLabel)
# row bind test and training data and then name them
subject <- rbind(subject_test, subject_train)
names(subject) <- "subjectId"
data <- rbind(data_test, data_train)
data <- data[, includedFeatures]
names(data) <- gsub("\\(|\\)", "", features$featureLabel[includedFeatures])
act <- rbind(act_test, act_train)
names(act) = "activityId"
activitytemp=merge(act, activities, by="activityId")
activity <- activitytemp$activityLabel
# column bind data frames of different columns to form one data table
data2 <- cbind(subject, data, activity)
write.table(data2, "tidy_data_merged.txt")
# create a dataset grouped by subject and activity
# after applying standard deviation and average calculations
dataDT <- data.table(data2)
calculatedData<- dataDT[, lapply(.SD, mean), by=c("subjectId", "activity")]
write.table(calculatedData, "tidy_data_calculated.txt")
}
gettidy
gettidy()
setwd ("C:/Users/Renu/RepData_PeerAssessment1")
